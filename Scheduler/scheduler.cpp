#include <stdlib.h>
#include <stdio.h>
#include <iostream>
#include <fstream>
#include <getopt.h>
#include <iomanip>
//#include <cstring>
#include <string>
#include <list>
#include <vector>
#include <queue>
#include <unordered_map> 

using namespace std;
//for calculating output
int time_cpubusy = 0; //CPU running time
int finishtime = 0;	
int time_iobusy = 0; //io busy time	

int random_val; // for storing random value generated by IO
int last_FT = 0; //last finish time
int last_remain_TC = 0;
int last_remain_CB = 0;

typedef enum{
CREATED,
READY,
RUNNING,
BLOCKED,
FINISHED
} process_state_t;

typedef enum{
    TRANS_TO_READY,
    TRANS_TO_PREEMPT,
    TRANS_TO_RUN,
    TRANS_TO_BLOCK,
} trans_state_t;
typedef enum{
    F,L,S,R,P,E
} scheduler_type;


class myrandom{
    private:
        vector<int> randvals;
        int ofs = 0;
        int n;
    public:
        int get(int burst){
            int ans = 1 + (randvals[ofs++%n] % burst);
            return ans; 
        };
        myrandom(){};
        ~myrandom(){
            randvals.clear();
        }

        //for reading randomfile input
        myrandom(char* file){
            ifstream in(file);
            string size;
            getline(in,size);
            randvals.resize(stoi(size));
            n = randvals.size();
            int val;
            for(int i = 0; i < n; i++){
                in>>val;
                randvals[i] = val;
            }
        }
};




struct process{
    int pid; //process id


    int AT; // arrival time
    int TC; // total cpu time
    int CB; // CPU Burst
    int IO; // IO Burst
    int PRIO; //priority
    
    int FT; //finish time
    int TT; //Turnaround time( finishing time  -   AT )
    int IT; //IO time(time in blocked state)
    int CW; //CPU waiting time





    process_state_t state;
    int state_ts; //time stamp
    int dPRIO; //dynamic priority
    int remain_TC; //remain total cpu time
    int remain_CB; //remain CPU Burst

    int run_times;//number of times the process get run
    // int last_remain_TC = 0;
    // int last_remain_CB = 0;

    



    process(int arrival_time, int total_cpu_time, int CPU_burst, int IO_burst, int priority,int proc_id){
        AT = arrival_time;
        TC = total_cpu_time;
        CB = CPU_burst;
        IO = IO_burst;
        FT = 0;
        TT = 0;
        IT = 0;
        CW = 0;
        state_ts = arrival_time;
        state = CREATED;
        PRIO = priority;
        dPRIO = PRIO-1;
        pid = proc_id;
        remain_TC = TC;
        remain_CB = 0;
        // run_times = 0;
        // last_remain_TC = 0;
        // last_remain_CB = 0;
    };

};
struct event{
    int t; //time stamp
    process* p; //process
    process_state_t prev; // prev state
    process_state_t next; // next state
    trans_state_t tran; // transition

    event(int time, process *proc, process_state_t prev_state, process_state_t next_state, trans_state_t transition){
        t = time;
        p = proc;
        prev = prev_state;
        next = next_state;
        tran = transition;
    }    
};


struct event_list{
    list<event *> l;
    int get_next_event_time(){
        if(l.empty()){
            return -1; 
        }
        else{
            return l.front()->t;
        }
    }
    event *get_event(){
        if(l.empty()){
            return nullptr; 
        }
        else{
            event *ans = l.front();
            l.pop_front();
            return ans;
        }
    }
    void push(event *e){
        if(l.empty()){
            l.push_back(e);
        }
        else{
            list<event*>::iterator it;
            for(it = l.begin();it!=l.end();++it){
                if((*it)->t>e->t){
                    l.insert(it,e);
                    break;
                }
            }
            if(it==l.end()){
                l.push_back(e);
            }
        }
    }

};

class scheduler{
public:
	scheduler() {};
	virtual ~scheduler() {};
    virtual void add_process(process *p) = 0;
    virtual process* get_next_process() = 0;
    scheduler_type type;
    //int quantum = 10000;
    bool preempt = false;


private:

};


//FCFS,  LCFS,  SRTF,  RR  (RoundRobin),  PRIO  (PriorityScheduler)  and  PREemptive  PRIO  (PREPRIO)


class FCFS:public scheduler{
    private:
        list<process*> l;
    public:
        FCFS(){
            type = F;
        }
        void add_process(process* p){
            p->state = CREATED;
            l.push_back(p);
        }
        process* get_next_process(){
            if(l.empty()){
                return nullptr;
            }
            else{
                auto p = l.front();
                l.pop_front();
                return p;
            }
        }
};
class LCFS:public scheduler{
    private:
        list<process*> l;
    public:
    LCFS(){
        type = L;
    }
    void add_process(process* p){
            p->state = CREATED;
            l.push_back(p);
    }
    process* get_next_process(){
            if(l.empty()){
                return nullptr;
            }
            else{
                auto& p = l.back();
                l.pop_back();
                return p;
            }
    }


    
};
class SRTF:public scheduler{
    private:
        list<process*> l;
    public:
    SRTF(){
        type = S;
    }
    void add_process(process* p){
            p->state = CREATED;
            list<process*>:: iterator it = l.begin();
            while(it!=l.end()){
                if((*it)->remain_TC > p->remain_TC){
                    l.insert(it,p);
                    break;
                }
                it++;
            }
            if(it==l.end()){
                l.push_back(p);
            }
    }
    process* get_next_process(){
        if(l.empty()){
                return nullptr;
            }
            else{
                auto& p = l.front();
                l.pop_front();
                return p;
            }
    }
};
class RR:public scheduler{
    private:
        list<process*> l;
    public:
    RR(){
        type = R;
    }
    void add_process(process* p){
            p->state = CREATED;
            l.push_back(p);
    }
    process* get_next_process(){
            if(l.empty()){
                return nullptr;
            }
            else{
                auto p = l.front();
                l.pop_front();
                return p;
            }
    }
};
class PRIO:public scheduler{
private:
    list<process *> active;
	list<process *> expired;
public:
    PRIO(){
        type = P;
    }
    void add_process(process* p){
        list<process*>::iterator it;
        if(p->state==RUNNING){
            p->dPRIO--;
        }
        else{
            p->dPRIO = p->PRIO-1;
        }
        p->state = READY;

        if(p->dPRIO == -1){
            p->dPRIO = p->PRIO - 1;
            for(it = expired.begin();it != expired.end();it++){
                if((*it)->dPRIO < p->dPRIO){
                    expired.insert(it,p);
                    break;
                }
            }
            if(it == expired.end()){
                expired.push_back(p);
            }
        }
        else{
            for(it = active.begin();it != active.end();it++){
                if((*it)->dPRIO < p->dPRIO){
                    active.insert(it,p);
                    break;
                }
            }
            if(it == active.end()){
                active.push_back(p);
            }
        }
    }
    process* get_next_process(){
        if(active.empty()&&expired.empty()){
            return nullptr;
        }
        if(active.empty()){
            list<process *> temp = expired;
            expired = active;
            active = temp;
        }
        process* p = active.front();
        active.pop_front();
        return p;
    }

};
class PREPRIO:public scheduler{
private:
    list<process *> active;
	list<process *> expired;

public:
    PREPRIO(){
        type = E;
        preempt = true;
    }
    void add_process(process* p){
        list<process*>::iterator it;
        if(p->state==RUNNING){
            p->dPRIO--;
        }
        else{
            p->dPRIO = p->PRIO-1;
        }
        p->state = READY;

        if(p->dPRIO == -1){
            p->dPRIO = p->PRIO - 1;
            for(it = expired.begin();it != expired.end();it++){
                if((*it)->dPRIO < p->dPRIO){
                    expired.insert(it,p);
                    break;
                }
            }
            if(it == expired.end()){
                expired.push_back(p);
            }
        }
        else{
            for(it = active.begin();it != active.end();it++){
                if((*it)->dPRIO < p->dPRIO){
                    active.insert(it,p);
                    break;
                }
            }
            if(it == active.end()){
                active.push_back(p);
            }
        }
    }
    process* get_next_process(){
        if(active.empty()&&expired.empty()){
            return nullptr;
        }
        if(active.empty()){
            list<process *> temp = expired;
            expired = active;
            active = temp;
        }
        process* p = active.front();
        active.pop_front();
        return p;
    }

};

int get_quantum(string s, int & maxprio){
    size_t found = s.find(':');
    if(found!=string::npos){
        maxprio = stoi(s.substr(found+1,string::npos));
    }
    return stoi(s.substr(1,found));
}

void simulation(scheduler * sched, event_list * el, vector<process*>& plist, int quantum, bool verbose, myrandom& r){
    event* evt;
    int current_time = 0;
    bool call_scheduler = false;
    process * current_running_process = nullptr;
    while((evt = el->get_event())){
        process *p = evt->p;
        //cout<<"pid::   "<<p->pid<<endl;
        current_time = evt->t;
        //cout<<"current time:   "<< current_time<< endl;
        int transition = evt->tran;
        int timeInPrevState = current_time - p->state_ts;
        delete evt;
        evt = nullptr;
        // cout<<"count: "<<count<<endl;

        switch(transition){
            case TRANS_TO_READY:
                // must come from BLOCKED or CREATED  
                // add to run queue, no event created
                if(current_running_process&&(p->state == BLOCKED || p->state == CREATED) && sched->preempt){
                    int ts = 0;
                    list<event*>::iterator it = el->l.begin();
                    while(it!=el->l.end()){
                        if((*it)->p->pid==current_running_process->pid){
                            ts = (*it)->t;
                            break;
                        }
                        it++;
                    }
                    if((current_time!=ts) && (ts > 0) && ((p->PRIO-1) > current_running_process->dPRIO)){
                        current_running_process->remain_TC = last_remain_TC-current_time+current_running_process->state_ts;
                        current_running_process->remain_CB = last_remain_CB-current_time+current_running_process->state_ts;
                        el->l.erase(it);
                        event *e = new event(current_time, current_running_process,RUNNING,READY,TRANS_TO_PREEMPT);
                        el->push(e);
                    }
                }
                p->state_ts = current_time;
                sched->add_process(p);
                call_scheduler = true;
                break;



            case TRANS_TO_PREEMPT:
                // must come from RUNNING (preemption)  
                // add to runqueue (no event is generated)
                p->state_ts = current_time;
                time_cpubusy += timeInPrevState;
                sched->add_process(p);
                call_scheduler = true;
                current_running_process = nullptr;
                break;

            case TRANS_TO_RUN:
                // create event for either preemption or blocking
                p->state = RUNNING;
                //current_running_process = p;
                plist[p->pid]->CW += timeInPrevState;
                p->state_ts = current_time;

                if(p->remain_CB==0){
                    p->remain_CB = r.get(p->CB);
                    p->remain_CB = min(p->remain_CB,p->remain_TC);
                }
                last_remain_TC = p->remain_TC;
                last_remain_CB = p->remain_CB;
                //finished
                if(((p->remain_CB <= quantum) && (p->remain_TC <= p->remain_CB))||
                    ((p->remain_CB>quantum) && (p->remain_TC<=quantum))
                ){
                    int ts = current_time+p->remain_TC;
                    p->state = FINISHED;
                    p->remain_TC = 0;
                    event *e = new event(ts,p,RUNNING,FINISHED,TRANS_TO_BLOCK);
                    el->push(e);
                }
                //to preemption
                else if((p->remain_TC>quantum) && (p->remain_CB>quantum)){
                    //p->state = BLOCKED;
                    p->remain_TC -= quantum;
                    p->remain_CB -= quantum;
                    event *e = new event(current_time+quantum,p,RUNNING,READY,TRANS_TO_PREEMPT);
                    el->push(e);
                }
                //to blocked
                else if((p->remain_TC>p->remain_CB)&&(p->remain_CB<=quantum)){
                    int ts = current_time+p->remain_CB;
                    p->remain_TC -= p->remain_CB;
                    //p->state = BLOCKED;
                    p->remain_CB = 0;
                    event *e = new event(ts,p,RUNNING,BLOCKED,TRANS_TO_BLOCK);
                    el->push(e);
                }
                break;

            case TRANS_TO_BLOCK:
                // create an event for when process becomes READY again

                if(p->state == FINISHED){
                    p->TT = current_time - p->AT;
                    plist[p->pid]->FT = current_time;
                    time_cpubusy +=timeInPrevState; 
                }
                else{
                    p->state = BLOCKED;
                    p->state_ts = current_time;
                    random_val = r.get(p->IO);
                    time_cpubusy += timeInPrevState;
                    int temp = current_time+random_val;
                    if(current_time > last_FT){
                        time_iobusy += random_val;
                        last_FT = temp;
                    }
                    else if(temp>last_FT){
                        time_iobusy += temp-last_FT;
                        last_FT = temp;
                    }
                    //cout<<"pid:   "<<p->pid;
                    plist[p->pid]->IT += random_val;

                    event *e = new event(current_time+random_val,p,BLOCKED,READY,TRANS_TO_READY);
                    el->push(e);
                }
                call_scheduler = true;    
                current_running_process = nullptr;
                break;

            default:
                break;

        }
        //cout<<"current_time:   " << current_time<<endl;
        if(call_scheduler){
            if(el->get_next_event_time() == current_time){
                continue;
            }
            call_scheduler = false;
            if(current_running_process == nullptr){
                //cout<<"current_running_process is nullptr"<<endl;
                current_running_process = sched->get_next_process();
                //cout<<"current pid:  "<<current_running_process->pid<<endl;
                if(current_running_process == nullptr){
                    continue;
                }
                event *evt2 = new event(current_time,current_running_process,READY,RUNNING,TRANS_TO_RUN);
                //cout<<"trans to run success"<<endl;
                el->push(evt2);
            }
        }
    //cout<<"finishtime:  "<<p->FT<<endl;
    //cout<<"pid:  "<< p->pid<<endl;
    }
    finishtime = current_time;
}








int main(int argc, char* argv[]){
    string mode = "";
    int maxprios = 4;
    int quantum = 10000;
    bool verbose = false;
    vector<process*> plist; 
    vector<string> algo = {"FCFS","LCFS","SRTF","RR","PRIO","PREPRIO"};

    int opt;
    while((opt = getopt(argc, argv, "vteps:")) != -1){
        switch(opt){
            case 'v':
                //verbose = true;
                break;
            case 't':
                break;
            case 'e':
                break;
            case 'p':
                break;
            case 's':
                mode = optarg;
                //cout<<mode<<endl;
                break;
            default:
                break;
        }
    }

scheduler* sched = nullptr;

   switch(mode[0]){
    case 'F':
        sched = new FCFS();
        break;
    case 'L':
        sched = new LCFS();
        break;
    case 'S':
        sched = new SRTF();
        break;
    case 'R':
        quantum = stoi(mode.substr(1,string::npos));
        //cout<<quantum<<endl;
        sched = new RR();
        break;
    case 'P':
        quantum = get_quantum(mode,maxprios);
        //cout<<quantum<<"     maxprios:    "<<maxprios<<endl;
        sched = new PRIO();
        break;
    case 'E':
        quantum = get_quantum(mode,maxprios);
        sched = new PREPRIO();
        break;
    default:
        break;
   
   }

    event_list* el = new event_list();
    char *inputfile = argv[optind];
    char *randfile = argv[optind+1];

    myrandom r(randfile);

    //cout<<inputfile;
    ifstream in(inputfile);
    int id = 0;
    if(!in.is_open()){
        cout<<"File cannot be opened!";
        exit(EXIT_FAILURE);
    }
    int AT,TC,CB,IO,PRIO;
    while(!in.eof()){
        in>>AT>>TC>>CB>>IO;
        if(in.eof()){
            break;
        }
        PRIO = r.get(maxprios);
        process* p = new process(AT,TC,CB,IO,PRIO,id);
        plist.push_back(p);
        event* evt = new event(AT,p,CREATED,READY,TRANS_TO_READY);
        el->push(evt);
        //cout<<"event list size:   "<<el->l.size()<<endl;
        id++;
    }


    simulation(sched,el,plist,quantum,verbose,r);
    cout<<algo[sched->type];
    if(sched->type>2){
        cout<<" "<<quantum;
    }
    cout<<endl;
    double TT = 0.0,CW=0.0;

    int num_processes = plist.size();
    for(int i = 0; i < num_processes;i++){
        printf("%04d: %4d %4d %4d %4d %1d | %5d %5d %5d %5d\n",
            plist[i]->pid,plist[i]->AT,plist[i]->TC,plist[i]->CB,
            plist[i]->IO,plist[i]->PRIO,plist[i]->FT,plist[i]->TT,
            plist[i]->IT,plist[i]->CW
        );
        CW+=plist[i]->CW;
        TT+=plist[i]->FT-plist[i]->AT;
    }


    double cpu_util   = 100.0 * (time_cpubusy  / (double) finishtime); 
    double io_util    = 100.0 * (time_iobusy   / (double) finishtime); 
    double throughput = 100.0 * (num_processes / (double) finishtime); 

    printf("SUM: %d %.2lf %.2lf %.2lf %.2lf %.3lf\n",
        finishtime,
        cpu_util,
        io_util,
        TT/num_processes,
        CW/num_processes,       
        throughput 
    );

    return 0;


}